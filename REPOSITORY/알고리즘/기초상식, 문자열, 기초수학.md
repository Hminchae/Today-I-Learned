## 알고리즘과 자료구조

---

<aside> 1️⃣ 자료구조란?

</aside>

**자료구조(Data Structure)는 개발자가 데이터를 효율적으로 사용할 수 있도록 정리하는 방법**을 말합니다.

예를 들어

```python
num1 = 1
num2 = 2
num3 = 15
num4 = 6
num5 = 8
num7 = 9
```

이렇게 따로 데이터를 관리하는 것보다

```python
num = [1, 2, 15, 6, 8, 9]
```

이렇게 Array구조를 사용하면 데이터를 더 효율적으로 저장하고 관리할 수 있습니다.

자료구조의 종류

자료구조는 크게 선형 자료구조와 비선형 자료구조로 나뉩니다.

![스크린샷 2024-03-15 오후 9.03.48.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/11f5fa36-6b8c-421c-92e0-039aed939026/381778d2-53b8-4bd1-abb8-09fe2fe08193/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-03-15_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_9.03.48.png)

- **선형 자료구조란 원소들을 하나씩 순차적으로 나열시킨 형태입니다.**
    
- 자료들 간의 앞뒤 관계가 1:1의 선형관계
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/11f5fa36-6b8c-421c-92e0-039aed939026/5a8056c8-1721-41ac-92bc-33ee2dc8680d/Untitled.png)
    

비선형 자료구조란 **하나의 자료 뒤에 여러개의 자료가 존재할 수 있는 형태**입니다.

- 자료들간의 앞, 뒤 관계가 **1:n 또는 n:n의 관계**를 나타냅니다.
- 트리와 그래프가 대표적이며, 계층적 구조를 나타내기에 적절합니다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/11f5fa36-6b8c-421c-92e0-039aed939026/b93f9551-ff41-41aa-bacc-4fad2dac289e/Untitled.png)

이 중 상(上)반에서 array, stack, queue, linked list, hash table을 다루고 중(中)반에서 tree, graph를 다룰 예정입니다.

<aside> 2️⃣ 알고리즘이란?

</aside>

**알고리즘은 문제를 해결하기 위한 단계적 절차**를 의미합니다.

알고리즘을 설계한다는 것은 문제 풀이 절차를 설계한다는 의미이고, 알고리즘을 구현한다는 것은 프로그래밍 언어를 이용해서 문제 풀이 절차를 실제로 동작하는 코드로 작성한다는 의미입니다.

**쉽게 말하면 알고리즘은** 문제를 해결하기 위한 정해진 일련의 절차나 방법이죠.

사람들이 많은 문제를 계속 풀다보니 자주 쓰이는 문제 해결 방법이 생겼는데 이 방법(알고리즘)을 패턴화시켜서 이름을 붙이게 된것입니다. (bfs, 다익스트라, 투포인터 등)

따라서 적절한 자료구조를 이용해 구현한 알고리즘으로 특정 문제를 매우 효율적으로 해결할 수가 있습니다. 결국, 알고리즘 문제풀이란 해당 문제를 풀기 위해 적절한 자료구조를 선택하고 그 자료구조를 이용해 적합한 알고리즘을 구현하는 것입니다.

예를 들어 bfs(알고리즘)에는 큐(자료구조)가 쓰이고 다익스트라(알고리즘)에는 힙(자료구조)이 쓰이게 됩니다.

그리고 사실 한 문제를 해결하는 알고리즘은 다양합니다. 따라서 문제에 가장 적합한 알고리즘을 선택할 수 있어야 하는데

이를 위해 각 알고리즘의 장단점과 특징을 알고 있어야 하는것이죠.

---

## 알고리즘 평가 기준

1. 시간 복잡도(Time Complexity)
2. 공간 복잡도(Space Complexity)
3. 구현 복잡도

한국기업에서는 보통 시간 복잡도를 가장 중요하게 보기 때문에 한국 기업 코딩 테스트를 준비한다면 사실상 시간 복잡도만 신경쓰면 됩니다. 그 다음 구현 복잡도를 고려하는게 좋습니다. 결국 제한된 시간에 문제를 풀어야하므로 구현을 간결하게 하는것도 중요하기 때문이죠.

시간복잡도와 공간 복잡도는 trade-off 관계입니다. 실행시간을 줄이기 위해서는 메모리를 더 사용해야 하고, 메모리 사용량을 줄이기 위해서는 시간을 더 사용해야하기 때문입니다.

코딩 테스트에서는 메모리를 사용해서 실행 시간을 줄이는게 중요하기 때문에 콜럼버스 스터디에서는 시간복잡도 계산 방법, 이에 맞는 자료구조/알고리즘 선택 방법을 지속적으로 훈련시킬것입니다.

시간 복잡도 계산법

![스크린샷 2024-03-16 오전 12.45.41.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/11f5fa36-6b8c-421c-92e0-039aed939026/5322c9e4-d5fa-42cc-b977-3237784ec669/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-03-16_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_12.45.41.png)

시간 복잡도의 실행시간은 다음과 같습니다.

어떤 문제의 시간 복잡도를 계산할 때 best case, average case, worst case를 생각해봐야합니다.

예를 들어 5,000개의 데이터가 있는 array에서 ‘A’라는 특정 값을 찾아본다고 가정해봅시다.

가장 앞에 있는 값부터 차례차례 검사를 한다고 하면

1. best case

가장 운이 좋은 경우 첫 번째 값이 ‘A’이면 1번만에 찾았으니 시간복잡도는 O(1)이 됩니다.

```python
array = ['A', 3, 5, 6, 8, 'B', ...] # 5,000개의 데이터
```

1. worst case

가장 운이 안 좋은 경우는 ‘A’가 array의 마지막에 있는 경우겠죠?

```python
array = [3, 5, 6, 8, 9, 'B', ... , 'A']  # 5,000개의 데이터
```

이 경우에는 총 5000번의 연산, 데이터의 개수만큼 시간이 걸렸으므로 시간복잡도가 O(n)이 됩니다.

그리고 마지막 average case의 경우 대부분의 문제에서 구하기가 쉽지 않습니다. 다행히 worst case와 average case는 거의 같기 때문에 worst case를 기준으로 시간복잡도를 계산해도 무방합니다.

결론 : worst case로 시간복잡도를 계산하자.

코딩 테스트에서 시간복잡도 계산법

지금까지는 문제에서 시간복잡도를 계산하는 방법이었고 실제 문제에서는 어떻게 적용해야 할까요?

모든 문제에는 제약조건이 있습니다.

```python
# 제약조건
1번 문제 : 1 <= n <= 10^5 # 10에 5승
2번 문제 : 1 <= n <= 10^3
3번 문제 : 1 <= n <= 8
```

만약 1번 문제를 O(n^2)의 시간복잡도를 가진 알고리즘으로 풀면 어떻게 될까요?

최악의 경우에 10^5의 제곱이므로 10^10, 즉 10의 10승이 나오게 되죠.

컴퓨터 환경이나 메모리 크기에 따라 편차가 조금씩 있겠지만 대부분의 코딩 테스트에서는 10^8을 넘으면 안됩니다. 10의 8승인 1억회의 연산을 하는데 1초가 걸린다고 생각하시면 계산하기 편하실 겁니다.

10^8 이내로 계산을 끝마쳐야하므로 1번 문제는 시간복잡도가 O(nlogn) 이나O(logn) 등을 가진 알고리즘으로 풀어야겠죠.

그럼 2번 문제는 어떨까요?

10^3을 제곱해도 10^6이므로 O(n^2)으로 풀어도 된다는 뜻입니다.

이런식으로 제약조건을 보고 어떤 시간복잡도를 가진 알고리즘을 써야할지 유추해볼 수 있습니다. 그렇다면 각 알고리즘이 어떤 시간복잡도를 가질까요? 이것은 직접 문제를 풀어보면서 정리하고 외워야합니다.

정리 : 1. 데이터 개수 * 시간 복잡도의 값이 10^8을 넘으면 안된다.

1. 10^8 이내로 계산 가능한 알고리즘 중에서 가장 효율적인 것을 찾는 연습을 해야한다.


## 1. 문자열

---

문자열은 크게 2가지 유형이 있습니다.

1. **문자열 단순 구현 문제**
2. **문자열 응용문제**

이 중 문자열 응용문제는 다루는 데이터가 문자열일 뿐이지 사실상 특정 알고리즘이나 자료구조를 다루는 것이 중점인 문제들입니다.

문자열을 다루는 것은 기본이고 dp, hash table 등 자료구조와 알고리즘을 얼마나 잘 활용하는지 보는 문제들이므로 반드시 먼저 기본 문자열 유형을 완벽하게 익혀야합니다.

기본 문자열 유형을 익히고 기타 알고리즘과 자료구조를 공부하면 자연스레 문자열 응용문제까지 익히게 될것입니다.

1주차에는 기본 문자열 유형(문자열 단순 구현 문제)를 연습하여 몇 가지 주요 문자열 함수들을 완벽하게 사용하는 것이 목표였습니다.

> **문자열 공부 방법**

언어마다 내장된 문자열 함수가 다르고 시험에서 요구하는 문자열 함수는 제한적이므로

몇 가지 중요한 함수를 익혀두고 잘 쓰이지 않는 함수는 굳이 외워둘 필요가 없습니다.

그때 그때 검색해서 사용하거나 몇 가지 함수를 응용해서 충분히 구현할 수 있기 때문이죠.

다음은 알아두어야 할 문자열 관련 함수들입니다. **다음 함수들만 자유롭게 사용할 수 있다면 문자열 문제는 완벽하게 대비할 수 있습니다.**

곧바로 함수가 떠오르지 않는다면 해당 기능을 가진 함수를 공부해보세요.

1주차의 필수,추천, 도전 문제들은 아래 함수들을 써보고 자주 쓰이는 함수는 외울수 있게끔 출제되었습니다. 해당 문제들을 반복적으로 풀면서 함수를 익혀보세요.

_이해를 돕기 위해 파이썬으로 예시를 들었고 본인의 언어에서 아래 기능을 담당하는 함수를 공부할 것._

_특정 언어에는 해당 기능을 가진 함수가 없을 수 있음. 유사한 기능을 가진 함수를 응용해야 함._

_예를 들어 Java의 compareTo() 함수는 파이썬에 없음._

1. **문자열 인덱싱 / 슬라이싱**

```python
a = 'abcd efg'

print(a[0], a[1], a[2], a[-2], a[-1]) # a b c f g

print(a[1:5]) # bcd

print(a[-3:-1]) # ef

print(a[:]) # abcd efg

print(a[3:]) # d efg

print(a[:3]) # print(a[:3]) # abc
```

1. **특정 문자가 있는지 확인**

```python
a = 'abcde'

print('d' in a) # True
```

1. **문자열이 같은지 비교**

```python
a = 'hello'
b = 'hello'

print(a is b) #True
```

1. **문자열 길이 반환**

```python
a = 'hello'

print(len(a)) #5
```

1. **특정 문자의 인덱스 값 찾기**

```python
a = 'hello'

print(a.index('h')) #0
```

1. **문자열을 구분자 기준으로 나누고 합치기**

```python
a = 'h,e,l,l,o'

print(a.split(',')) # ['h', 'e', 'l', 'l', 'o']
```

1. **문자열 대소문자 변환**

```python
a = 'a,b,c,D,E'

print(a.upper()) # A,B,C,D,E

print(a.lower()) # a,b,c,d,e
```

1. **기존 값을 다른 값으로 치환**

```python
a = 'h,e,l,l,o'

print(a.replace(',', '/')) # h/e/l/l/o
```

1. **양쪽 끝에서 특정 문자(혹은 공백) 제거**

```python
a = '   abc   '
print(a.strip()) # 'abc'

a = '12321abc111'
print(a.strip('123')) # abc
```

1. **아스키코드로 변환 혹은 대소 비교**

```python
print(ord('a') > ord('b')) #False
print(ord('a') , ord('b')) # 97 98
```

## 2. 기초 수학

---

코딩 테스트를 위한 수학적 지식은 중학교 수준이면 충분합니다 (간혹 어려운 개념이 나오기도 함).

다만 이를 코드로 구현하는 연습은 반드시 해봐야하기 때문에 중요한 수학 개념을 정리해 드릴테니 본인이 부족한 부분은 관련 문제를 검색해서 풀어 보시길 바랍니다.

또한 수학문제는 그 자체로 출제가 되는 경우는 없고 여러가지 유형이 섞여서 나옵니다. 예를 들어 카카오 기출문제 중 소수를 판별해서 진법 변환하는 문제가 있는데 소수 판별법을 알고 있다면 빠르게 풀 수 있는 문제죠. 따라서 중요한 수학 개념들은 외워두고 빠르게 코드로 작성할 수 있게 연습해두어야합니다.

1주차의 수학문제는 필요한 수학지식을 코드로 구현해 볼 수 있는 문제들로 출제되었습니다. 정말 중요한 개념들이니 반복적으로 풀어보세요.

<aside> 1️⃣ **GCD/LCM** (최대공약수, 최소공배수)

</aside>

<aside> 2️⃣ **소수 판별** (에라토스테네스의 체와 제곱근을 이용한 소수 판별법을 꼭 알아둘 것)

</aside>

<aside> 3️⃣ **나머지, 몫 구하기** (이를 이용한 응용문제가 많이 나옴)

</aside>

<aside> 4️⃣ **순열, 조합**(본인이 사용하는 언어에 내장 라이브러리가 있더라도 직접 구현해 볼 것)

</aside>

> 추가로 알아두면 좋은 개념
> 
> - 진법 변환(2진수, 8진수, 16진수 등)
> - 소인수분해



<aside> 1️⃣ 알고리즘/자료구조란?

</aside>

→ 나만의 답을 적어주세요.

<aside> 2️⃣ 시간복잡도/공간복잡도/빅오 표기법이란?

</aside>

→ 나만의 답을 적어주세요.

<aside> 3️⃣ 다음 기능을 가진 함수를 본인 언어로 정리하시오.

</aside>

1. 문자열 인덱싱 / 슬라이싱

1. 특정 문자가 있는지 확인

1. 문자열이 같은지 비교

1. 문자열 길이 반환

1. 특정 문자의 인덱스 값 찾기

1. 문자열을 구분자 기준으로 나누고 합치기

1. 문자열 대소문자 변환

1. 기존 값을 다른 값으로 치환

1. 양쪽 끝에서 특정 문자(혹은 공백) 제거

1. 아스키코드로 변환 혹은 대소 비교