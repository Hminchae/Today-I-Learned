#컴파일 #최적화 
#### 모듈 컴파일
- 단일 파일 컴파일의 경우, 모듈 내 파일들을 하나씩 컴파일 함
- 한계 : 파일내에 컴파일만 이루어짐
	- function inlining 이 안 됨
	- function specialization 이 안 됨
	-  ➡️ 결국 컴파일 시간이 길어짐

#### WMO(Whole-Module Optimization)

- 모듈 전체를 확인, 단일 파일 컴파일의 한계를 극복
- 장점 
	- function inlining 이 가능
	- function specialization 이 가능
	- 불필요한 referencing counting 제거
	- 적은 수의 기계 명령어 생성
- 장점2
	- non-public 함수에 대한 분석
	- 죽은 함수를 찾아냄
	- 컴파일 최적화 -> 컴파일 시간 단축
> WMO의 경우 컴파일 시간은 늘어날 수 있지만 실행속도는 빨라지는게 아닌가?

#### 컴파일 시간
- 컴파일 : 소스파일을 일고, 파싱하고나서 컴파일러는 스위프트 코드를 최적화하고, 기계코드를 만들고, 오브젝트 파일을 만듬. 마지막으로는 링커가 모든 오브젝트 파일들을 합치고, 공유 라이브러리 혹은 실행가능한 것을 만든다.
- 컴파일 과정에는 파싱, 타입체킹, SIL, LLVM 등이 포함된다.
	- 파싱, 타입체킹 : 엄청 빨리 끝나는 작업
	- SIL : 전체 컴파일 시간의 1/3 정도를 차지
	- LLVM : 나머지 컴파일 시간을 차지(2/3 정도)
- SIL 작업에서 WMO 가 최적화되고 다시 LLVM 작업시 병렬로 처리가 되기 때문에 문제가 없음 ??
![[스크린샷 2024-07-01 오후 2.23.28.png]]
- 컴파일러가 어떤 00.swift 라는 파일을 최적화할 때, 이 파일 내에 있는 something() 이라는 함수의 getSomthing() 메서드는 어떻게 구현되어 있는지 모른채 그냥 쓰인다고만 알고 있는 상태다.  제네릭 타입을 반환하는 함수를 가지고 있는 파일을 최적화한다고 하면, 이 함수가 단순히 리턴하는 부분이 어떻게 인자를 복사하는지 ㅇ알기 위하여 타입의 메타데이터를 검색하게 됨. 이 타입이 단순히 Int 타입이 될 수 도 있지만, 더 큰 무언가가 될 수도 있으며 이 작업이 referencing counting 을 수반하는 작업일 수 도 있음. 컴파일러는 그냥은 모름!!
- 하지만! WMO 는 다르다!
- `- wmo` 라는 옵션과 함께 컴파일 하면 컴파일러는 모듈안에 있는 스위프트 파일 전체를 통으로 최적화 시키게 됨. 이건 이제 크게 두가지 장점이 있다. 
	- 첫번째, 컴파일러가 모듈안에 함수가 구현된 상태를 모두 확인 함., function inlining 혹은 function 구체화같은 최적화를 수행할 수  있음. 함수 구체화는 컴파일러가 최적화하기 위하여 특정 호출 상황에 맞는 함수를 새로 만들수도 있음. 이 과정은 곧 적은 수의 기계 명령어로 컴파일을 시켜준다는 말임. 사실 이건 파일 하나씩 할때랑은 매우 큰 차이가 있음. 함수 구체화 혹은 파일간의 Inlining들은 단순히 컴파일러 최적화의 한 예이다. 컴파일러가 함수를 Inlining 하지 않아도, 함수 구현을 볼 수 있는 것만으로도 최적화에 도움이 된다. 예를 들어 reference counting 관련하여 분석을 하는데도 도움이 됨 . 따라서 컴파일러는 함수 호출과 관련된 불필요한 reference counting 작업을 제거할 수 도 있음
	- 두번째, non-public 함수 사용에 대한 분석을 할 수 있음. non-public 함수는 모듈안에서만 사용하게 됨. 그래서 컴파일러는 이러한 non-public 함수 대한 참조를 확실히 볼 수 있게 됨.그러면 이제 컴파일러는 무엇을 하느냐 ,  코드내에서 절대 안 불리는 죽은 함수들을 제거해줌!! 
- WMO에선 SIL 최적화가 수행되고 나서 모듈을 다시 여러개의 파트로 분리한다. LLVM 백엔드에서는 앞서 분리된 여러개의 파트들을 멀티 스레드에서 처리함. 이 과정에서도 이전에 빌드 되고 수정이 안된 부분들은 재처리가 안 되도록 함. 그래서 wmo 가 켜져있어도, 컴파일러는 많은 부분의 컴파일 작업을 병렬 처리 및 incrementally 수행할 수 있음

#### 정리
WMO는 Swift 코드를 모듈내에 어떻게 분산시켜야 하는지에 대한 걱정없이 최고의 효율성을 가질 수 있는 방법. 만약 최적화가 매우 중요한 코드 섹션에 들어가게 되면, 성능은 단일 파일 컴파일 할 때보다 최대 5배 가량 향상될 수 있음. 그리고 이 방법은 일반적인 방법보다 더 짧은 컴파일 시간을 가지게  됨

#### 참고
- [WMO 알아보기(컴파일 최적화)](https://brunch.co.kr/@joonwonlee/14)