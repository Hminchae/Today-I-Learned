태그 : #CS #운영체제 #메모리 #페이징

- 연속 메모리 할당 : 프로세스에 연속적인 메모리 공간을 할당
	- 단점 
		- 외부 단편화
		- 물리메모리보다 큰 프로세스 실행 불가
- 스와핑
	- 현재 사용되지 않는 프로세스들을 보조기억장치의 일부 영역(스왑영역)으로 쫓아내고(스왑 아웃)
	- 그렇게 생긴 빈 공간에 새 프로세스를 적재하는 것(스왑 인)
	- 프로세스들이 요구하는 메모리 공간 크기 > 실제 메모리 크기 여도 메모리에 올릴 수 있음 
- 메모리 할당
	- 프로세스는 메모리의 빈 공간에 할당 되어야 한다.. 빈 공간이 여러개 있다면?
	- -> 최초 적합, 최적 적합, 최악 적합
		- 최초 적합(first-fit)
			- 운영체제가 메모리 내의 빈 공간을 순서대로 검색하다가 적재할 수 있는 공간을 발견하면 그 공간에 프로세스를 배치하는 방식
			- 검색 최소화, 빠른 할당
		- 최적 적합(best-fit)
			- 운영체제가 빈 공간을 모두 검색해본 뒤, 적재 가능한 가장 작은 공간에 할당
		- 최악 적합(worst-fit)
			- 운영체제가 빈 공간을 모두 검색해본 뒤, 적재 가능한 가장 큰 공간에 할당
- 외부 단편화
	- 프로세스들이 실행되고 종료되길 반복하며 메모리 사이 사이에 빈 공간 발생
	- -> 즉 프로세스를 할당하기 어려울 만큼 작은 메모리 공간들로 인해 메모리가 낭비되는 현상
	- 외부 단편화 해결 
		1. 메모리 압축(compaction) : 여기저기 흩어져 있는 빈 공간들을 하나로 모으는 방식, 프로세스를 적당히 재배치시켜 흩어져 있는 작은 빈 공간들을 하나의 큰 빈 공간으로 만드는 방법
		2. 가상 메모리 기법, 페이징
			- 가상 메모리
				- 실행하고자 하는 프로그램을 일부만 메모리에 적재하여 실제 물리 메모리 크기보다 더 큰 프로세스를 실행할 수 있게 하는 기술
				- 페이징, 세그멘테이션
			-  페이징(paging)
				- 프로세스의 논리 주소 공간을 페이지(page)라는 일정 단위로 자르고,
				- 메모리의 물리 주소 공간을 프레임(frame)이라는 페이지와 동일한 일정 단위로 자른 뒤 
				- 페이지를 프레임에 할당하는 가상 메모리 관리 기법
				- 페이징에서의 스와핑
					- 프로세스 단위의 스왑 인, 스왑 아웃이 아닌 페이지 단위의 스왑인(페이지 인), 스왑 아웃(페이지 아웃)
					- 메모리에 적재될 필요가 없는 페이지들은 보조기억장치로 스왑 아웃
					- 실행에 필요한 페이지들은 메모리로 스왑인
					- 프로세스를 실행하기 위해 모든 페이지가 적재될 필요 없음
					- 달리 말해 물리 메모리보다 큰 프로세스도 실행될 수 있음
					- 어 근데 ? 
						- 프로세스를 이루는 페이지가 어느 프레임에 적재되어 있는지 CPU가 일일이 알기란 어려움..
						- 프로세스가 메모리에 불연속적으로 배치되어 있다면, CPU 입장에서 이를 순차적으로 실행할 수 가 없음
						- CPU입장에서 `다음에 실행할 명령어 위치`를 찾기가 어려워짐
					- 그래서 ! 페이지 테이블
						- (실제 메모리 내의 주소인) 물리 주소에 불연속적으로 배치되더라도
						- (CPU가 바라보는 주소인) 논리 주소에는 연속적으로 배치되도록 하는 방법
						- 페이지 번호와 프레임 번호를 짝지어 주는 일종의 이정표
						- ==CPU는 그저 논리주소를 순차적으로 실행하면 될 뿐==
					- 내부 단편화
						- 페이지 크기가 10KB, 프로세스 크기가 108KB?
						- 2KB: 내부 단편화
						- 하나의 페이지 크기보다 작은 크기로 발생![[스크린샷 2024-05-02 오후 7.00.08.png]]
						- 내 페이지 크기 ㅎㅎ
					- PTBR
						- 프로세스마다 페이지 테이블이 있고,
						- 각 페이지 테이블은 CPU내의 프로세스 테이블 베이스 레지스터(PTBR)가 가리킴
						- 그런데, 페이지 테이블이 메모리에 있으면? 메모리 접근 시간 두 배로..
						- 페이지 테이블 참조하기 위해 한 번 + 페이지 참조하기 위해 한 번
						- 그래서.. TLB
					- TLB
						- CPU 곁에 페이지 테이블의 캐시 메모리
						- 페이지 테이블의 일부를 가져와 저장
						- CPU가 접근하려는 논리주소가 TLB에 있다면? TLB 히트
							- 메모리에 접근 한 번
						- CPU가 접근하려는 논리주소가 TLB에 없다면? TLB 미스
							- 메모리에 접근 두 번
					- 페이징에서의 주소 변환
						- 특정 주소에 접근하고자 한다면 어떤 정보가 필요할까?
							- 어떤 페이지/프레임에 접근하고 싶은지
							- 접근하려는 주소가 그 페이지 혹은 프레임으로부터 얼마나 떨어져 있는지
							- 그래서! 페이징시스템에서의 논리주소는..
								- 페이지 번호, 변위(offset)
							- 정리
								- <페이지 번호, 변위>로 이루어진 논리주소는
								- 페이지 테이블을 통해
								- <프레임 번호, 변위>로 변환된다.
					- 페이지 테이블 엔트리
						- 유효비트
							- 현재 해당 페이지에 접근 가능한지 여부 
								- 메모리에 적재 ~ 
								- 스왑영역에 적재 ~ 등등
							- 유효 비트가 0인 페이지에 접근하려고 하면 페이지 폴트라는 인터럽트가 발생
								1. CPU는 기존의 작업 내역을 백업
								2. 페이지 폴트 처리 루틴을 실행
								3. 페이지 처리 루틴은 원하는 페이지를 메모리로 가져온 뒤 유효 비트를 1로 변경해 줌
								4. 페이지 폴트를 처리했다면 이제 CPU는 해당 페이지에 접근할 수 있게 됨
						- 보호비트
							- 페이지 보호 기능을 위해 존재하는 비트
								- 읽기전용 페이지냐..
						- 수정비트
							- CPU가 이 페이지에 데이터를 쓴 적이 있는지 여부
							- 수정된 페이지는 스왑 아웃될 대 보조기억장치에도 쓰기 작업 과정을 거쳐야함