### 1. HTTP와 HTTPS의 차이점, iOS에서의 보안 통신 방법에 대해 설명해주세요.
---
##### HTTP(Hyper Text Transfer Protocol)
- 인터넷에서 하이퍼텍스트를 교환하기 위한 프로토콜
- 1989년 팀 버너스 리에 의해 설계
- 상태를 가지지 않는(Stateless) 프로토콜
- 주로 80번 포트 사용
- 데이터 암호화가 추가되지 않아 보안에 취약
##### HTTP의 구조
![[Pasted image 20240403020259.png]]
##### HTTPS (Hyper Text Transfer Protocol Secure)
- HTTP에 데이터 암호화가 추가된 프로토콜
- 주로 443번 포트 사용
- 대칭키와 비대칭키 암호화 방식 모두 사용
    - 대칭키: 속도가 빠르지만 키 노출 시 위험
    - 비대칭키: 안전하지만 속도가 느림. 공개키와 개인키를 사용
- HTTPS의 동작 과정은 대칭키(세션키)를 안전하게 교환하기 위해 비대칭키를 사용한 초기 단계 후, 실제 데이터 교환은 세션키를 사용
##### HTTP와 HTTPS 사용 상황
- HTTPS는 개인 정보와 같은 민감한 데이터를 처리할 때 사용하는 것이 바람직
- 단순한 정보 조회 등 민감한 정보가 아닌 경우, HTTP 사용이 가능
- HTTPS는 추가적인 비용이 발생할 수 있으나, 보안을 위해 널리 사용됨

3. **SSL/TLS**
    - `URLSession` 암호화된 HTTPS 통신 기본
    - 보안 데이터 전송 시 HTTPS 필수
    - 서버 인증서 유효성 검사 가능
### 2. TCP와 UDP의 차이점에 대해서 설명해 주세요.
---
##### TCP(Transmission Control Protocol)
1. **연결 지향성**
    - 핸드셰이크 과정으로 연결 성립 후 데이터 전송
2. **데이터 전송 신뢰성**
    - 데이터 순서 보장
    - 데이터 손실 시 재전송
3. **속도**
    - 신뢰성과 순서 보장으로 인한 상대적 느림
4. **용도**
    - 이메일, 웹 페이지 로딩 등 신뢰성 중시 애플리케이션
5. **흐름 제어 및 혼잡 제어**
    - 데이터 흐름 조절, 네트워크 혼잡 시 속도 조절
6. **오버헤드**
    - 헤더 크기 크고, 연결 유지를 위한 추가 정보 필요
##### UDP(User Datagram Protocol)
1. **비연결 지향성**
    - 핸드셰이크 없이 바로 데이터 전송
2. **데이터 전송 신뢰성**
    - 순서 보장 없음
    - 데이터 손실 시 재전송 없음
3. **속도**
    - 최소한의 오버헤드로 빠른 데이터 전송
4. **용도**
    - 스트리밍, 온라인 게임 등 실시간성 중요 애플리케이션
5. **흐름 제어 및 혼잡 제어**
    - 미지원. 데이터 흐름과 네트워크 혼잡 상태 고려 안 함
6. **오버헤드**
    - 헤더 크기 작고, 최소한의 정보로 구성
### 3. 소켓 통신에 대해 설명해주세요.
---
##### 소켓통신
1. **정의**
    - 네트워크 상에서 프로그램 간 데이터를 주고받기 위한 통신 방법
2. **구성 요소**
    - IP 주소: 네트워크 상에서 기기를 식별
    - 포트 번호: 같은 기기 내에서 프로그램을 구분
3. **동작 원리**
    - 클라이언트-서버 모델 기반
    - 서버: 소켓 생성, 주소 바인딩, 연결 대기, 연결 수락
    - 클라이언트: 소켓 생성, 서버에 연결 요청
4. **프로토콜**
    - TCP: 연결 지향적, 데이터 전송의 신뢰성 보장
    - UDP: 비연결 지향적, 빠르지만 신뢰성 낮음
5. **용도**
    - 다양한 네트워크 애플리케이션 개발에 사용 (웹 서버, 채팅 애플리케이션 등)
6. **장점**
    - 양방향 통신 가능
    - 실시간 데이터 교환 가능
7. **단점**
    - 복잡한 네트워크 설정과 오류 처리 필요
    - 프로토콜에 따라 구현 방법과 사용성 다름
### 4. REST API와 iOS에서의 네트워크 요청 및 응답 처리 방법에 대해 설명해주세요.
---
##### REST API
1. **정의**
    - Representational State Transfer의 약자
    - 네트워크 상에서 클라이언트와 서버 간의 통신을 위한 아키텍처 스타일
2. **특징**
    - 상태 정보를 유지하지 않는 Stateless 통신
    - HTTP 메서드 사용 (GET, POST, PUT, DELETE 등)
3. **자원 표현**
    - JSON, XML 등을 사용하여 데이터 교환
4. **용도**
    - 웹 서비스 API 개발에 널리 사용
#####  iOS에서의 네트워크 요청 및 응답 처리 방법
1. **URLSession 사용**
    - 네트워크 작업을 위한 iOS 내장 클래스
    - 데이터, 파일, 스트림 및 HTTP, HTTPS 프로토콜 지원
2. **네트워크 요청 생성**
    - `URLRequest` 객체 사용
    - URL, HTTP 메서드, 헤더, 바디 설정
3. **비동기 요청 수행**
    - `URLSession.shared.dataTask` 메서드 사용
    - 비동기적으로 데이터 태스크 생성 및 실행
4. **응답 및 데이터 처리**
    - 클로저(Closure) 내에서 응답(Response) 및 데이터(Data) 처리
    - JSON 데이터는 `JSONDecoder`를 사용하여 모델 객체로 디코딩
5. **오류 처리**
    - 네트워크 요청 실패 시 오류(Error) 객체로 처리
    - 상태 코드(Status Code) 확인을 통한 서버 응답 분석
6. **비동기 프로그래밍**
    - Swift 5.5 이상에서는 `async/await` 패턴 사용 가능
### 5. REST API에서 Method들의 차이점을 설명해주세요.
---
1. **GET**
    - 데이터 조회용
    - 서버에서 정보를 검색하여 응답
    - 데이터 변경 없음
2. **POST**
    - 데이터 생성용
    - 서버에 데이터를 전송하여 리소스 생성
    - 같은 요청을 여러 번 보내면 여러 번 생성될 수 있음
3. **PUT**
    - 데이터 업데이트/전체 교체용
    - 지정된 URI에 데이터를 저장하거나, 이미 존재하면 전체를 교체
    - 같은 요청을 여러 번 보내도 하나의 리소스만 생성/변경
4. **DELETE**
    - 데이터 삭제용
    - 지정된 URI의 리소스를 삭제
5. **PATCH**
    - 데이터 부분 업데이트용
    - 리소스의 일부분만 수정하고자 할 때 사용
    - PUT과 다르게 전체 교체가 아닌 일부 변경 가능
6. **HEAD**
    - GET과 유사하지만, 응답 본문(body) 없이 헤더 정보만 조회
    - 리소스의 메타데이터 또는 상태 확인용
7. **OPTIONS**
    - 웹 서버에서 지원하는 메서드를 확인용
    - 주로 CORS(Cross-Origin Resource Sharing) 사전 요청 처리에 사용
### 6. HTTP 상태 코드에 대해서 설명해주세요.
---
1. **1xx: 정보 응답**
	- **100 Continue**: 초기의 요청이 받아들여졌으며 클라이언트는 요청을 계속해야 함

2. **2xx: 성공**
	- **200 OK**: 요청 성공적으로 수행됨.
	- **201 Created**: 요청이 성공적으로 이행되어 새로운 리소스가 생성됨
	- **204 No Content**: 성공적으로 처리되었으나, 컨텐츠를 제공하지 않음

3. **3xx: 리다이렉션**
	- **301 Moved Permanently**: 요청한 리소스가 영구적으로 새 위치로 이동함
	- **302 Found**: 요청한 리소스가 일시적으로 다른 주소로 이동함
	- **304 Not Modified**: 캐시된 버전이 최신 상태임

4. **4xx: 클라이언트 에러**
	- **400 Bad Request**: 서버가 요청을 이해할 수 없음
	- **401 Unauthorized**: 인증이 필요함
	- **403 Forbidden**: 서버가 요청을 거부함
	- **404 Not Found**: 요청한 리소스를 찾을 수 없음
	- **429 Too Many Requests**: 너무 많은 요청으로 인해 서버가 처리를 거부함

5. **5xx: 서버 에러**
	- **500 Internal Server Error**: 서버 내부 오류로 요청을 처리할 수 없음
	- **501 Not Implemented**: 서버가 요청을 수행할 수 있는 기능을 지원하지 않음
	- **503 Service Unavailable**: 서버가 일시적으로 요청을 처리할 수 없음. 대개 유지 보수나 오버로드 때문에 발생